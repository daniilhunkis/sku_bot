from __future__ import annotations

import json

from aiogram import Router, F, Bot
from aiogram.types import BufferedInputFile
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, BufferedInputFile
from aiogram.fsm.context import FSMContext
from aiogram.filters import CommandStart

from app.repo import Repo
from app.keyboards import (
    main_menu_kb,
    marketplaces_kb,
    schemes_kb,
    commission_mode_kb,
    ads_mode_kb,
    tax_mode_kb,
    input_help_kb,
    result_kb,
    packs_kb,
    result_saved_kb,
)
from app.states import CalcFlow
from app.services.calc import CalcInputs, compute
from app.services.pdf_report import build_pdf
from app.utils import fmt_money, fmt_pct

from aiogram.utils.keyboard import InlineKeyboardBuilder

router = Router()


def _set_input(data_inputs: dict, key: str, value, source: str) -> None:
    data_inputs[key] = {"value": value, "source": source}


def _get_input(data_inputs: dict, key: str):
    return data_inputs.get(key, {}).get("value")


async def _ensure_state_basics(state: FSMContext) -> None:
    data = await state.get_data()
    if "inputs" not in data:
        await state.update_data(inputs={})


FRIENDLY_FIELD_NAMES = {
    "price": "–¶–µ–Ω–∞ –ø—Ä–æ–¥–∞–∂–∏",
    "cogs": "–°–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å",
    "commission_mode": "–†–µ–∂–∏–º –∫–æ–º–∏—Å—Å–∏–∏",
    "commission_value": "–ö–æ–º–∏—Å—Å–∏—è –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–∞",
    "logistics": "–õ–æ–≥–∏—Å—Ç–∏–∫–∞",
    "storage": "–•—Ä–∞–Ω–µ–Ω–∏–µ",
    "returns_pct": "–î–æ–ª—è –≤–æ–∑–≤—Ä–∞—Ç–æ–≤",
    "return_cost": "–°—Ç–æ–∏–º–æ—Å—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–æ–∑–≤—Ä–∞—Ç–∞",
    "ads_mode": "–†–µ–∂–∏–º —Ä–µ–∫–ª–∞–º—ã",
    "ads_value": "–†–∞—Å—Ö–æ–¥—ã –Ω–∞ —Ä–µ–∫–ª–∞–º—É",
    "other_fees": "–ü—Ä–æ—á–∏–µ —Å–±–æ—Ä—ã",
    "opex_var": "–ü—Ä–æ—á–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã",
    "tax_mode": "–†–µ–∂–∏–º –Ω–∞–ª–æ–≥–æ–æ–±–ª–æ–∂–µ–Ω–∏—è",
    "tax_rate": "–°—Ç–∞–≤–∫–∞ –Ω–∞–ª–æ–≥–∞",
}


def _notes(data_inputs: dict) -> tuple[str, list[str]]:
    defaults = [
        k
        for k, v in data_inputs.items()
        if v.get("source") == "DEFAULT" and float(v.get("value") or 0) != 0
    ]
    zeros = [
        k
        for k, v in data_inputs.items()
        if v.get("source") == "ZERO" and float(v.get("value") or 0) == 0
    ]

    if len(defaults) <= 1 and len(zeros) <= 1:
        lvl = "üü¢ –í—ã—Å–æ–∫–∞—è (–∫–ª—é—á–µ–≤—ã–µ —Ü–∏—Ñ—Ä—ã –≤–≤–µ–¥–µ–Ω—ã –≤–∞–º–∏)"
    elif len(defaults) <= 4 and len(zeros) <= 3:
        lvl = "üü° –°—Ä–µ–¥–Ω—è—è (–µ—Å—Ç—å —Å–ø—Ä–∞–≤–æ—á–Ω—ã–µ/–Ω—É–ª–µ–≤—ã–µ –ø–æ–ª—è)"
    else:
        lvl = "üî¥ –ù–∏–∑–∫–∞—è (–º–Ω–æ–≥–æ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–π; –ª—É—á—à–µ —É—Ç–æ—á–Ω–∏—Ç—å —Ü–∏—Ñ—Ä—ã)"

    notes: list[str] = []
    for k in defaults:
        label = FRIENDLY_FIELD_NAMES.get(k, k)
        notes.append(f"{label}: —Å–ø—Ä–∞–≤–æ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ")
    for k in zeros:
        label = FRIENDLY_FIELD_NAMES.get(k, k)
        notes.append(f"{label}: –Ω–µ —É—á–∏—Ç—ã–≤–∞–ª–æ—Å—å (0)")
    return lvl, notes


def _build_calcinputs(data_inputs: dict) -> CalcInputs:
    return CalcInputs(
        price=float(_get_input(data_inputs, "price")),
        cogs=float(_get_input(data_inputs, "cogs")),
        commission_mode=_get_input(data_inputs, "commission_mode"),
        commission_value=float(_get_input(data_inputs, "commission_value")),
        logistics=float(_get_input(data_inputs, "logistics")),
        storage=float(_get_input(data_inputs, "storage")),
        returns_pct=float(_get_input(data_inputs, "returns_pct")),
        return_cost=float(_get_input(data_inputs, "return_cost")),
        ads_mode=_get_input(data_inputs, "ads_mode"),
        ads_value=float(_get_input(data_inputs, "ads_value")),
        other_fees=float(_get_input(data_inputs, "other_fees")),
        opex_var=float(_get_input(data_inputs, "opex_var")),
        tax_mode=_get_input(data_inputs, "tax_mode"),
        tax_rate=float(_get_input(data_inputs, "tax_rate")),
    )


def _safe_float(text: str) -> float:
    t = text.strip().replace(" ", "").replace(",", ".")
    return float(t)


def _pct_to_frac(text: str) -> float:
    return _safe_float(text) / 100.0


def _field_prompt(field: str, state_data: dict) -> tuple[str, str]:
    if field == "price":
        return (
            "–í–≤–µ–¥–∏—Ç–µ —Ü–µ–Ω—É –ø—Ä–æ–¥–∞–∂–∏ (‚ÇΩ).",
            "–ù—É–∂–Ω–æ –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ –≤—ã—Ä—É—á–∫–∏ –∏ –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤ (–∫–æ–º–∏—Å—Å–∏—è/–î–†–†).",
        )
    if field == "cogs":
        return (
            "–í–≤–µ–¥–∏—Ç–µ —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å (‚ÇΩ).",
            "–ó–∞–∫—É–ø–∫–∞ + —É–ø–∞–∫–æ–≤–∫–∞. –ë–µ–∑ –Ω–µ—ë –ø—Ä–∏–±—ã–ª—å –±—É–¥–µ—Ç –∑–∞–≤—ã—à–µ–Ω–∞.",
        )
    if field == "commission_mode":
        return (
            "–ö–∞–∫ —É–∫–∞–∑–∞—Ç—å –∫–æ–º–∏—Å—Å–∏—é –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–∞?",
            "–ö–æ–º–∏—Å—Å–∏—è ‚Äî –ø—Ä—è–º–æ–π –≤—ã—á–µ—Ç –∏–∑ –≤—ã—Ä—É—á–∫–∏.",
        )
    if field == "commission_value":
        cm = (state_data.get("inputs", {}).get("commission_mode", {}) or {}).get(
            "value"
        )
        if cm == "PCT":
            return (
                "–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∏—Å—Å–∏—é (%). –ù–∞–ø—Ä–∏–º–µ—Ä: 18",
                "–ö–æ–º–∏—Å—Å–∏—è —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –∫–∞–∫ % –æ—Ç —Ü–µ–Ω—ã.",
            )
        return (
            "–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∏—Å—Å–∏—é (‚ÇΩ).",
            "–ö–æ–º–∏—Å—Å–∏—è –≤—ã—á–∏—Ç–∞–µ—Ç—Å—è –∏–∑ –∫–∞–∂–¥–æ–π –ø—Ä–æ–¥–∞–∂–∏.",
        )
    if field == "logistics":
        return (
            "–í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏—Å—Ç–∏–∫—É –Ω–∞ 1 –ø—Ä–æ–¥–∞–∂—É (‚ÇΩ).",
            "–ß–∞—Å—Ç–æ –ª–æ–≥–∏—Å—Ç–∏–∫–∞ ¬´—Å—ä–µ–¥–∞–µ—Ç¬ª –º–∞—Ä–∂—É.",
        )
    if field == "storage":
        return (
            "–í–≤–µ–¥–∏—Ç–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ (‚ÇΩ –Ω–∞ 1 –ø—Ä–æ–¥–∞–∂—É).",
            "–ï—Å–ª–∏ —Ç–æ–≤–∞—Ä –ª–µ–∂–∏—Ç –¥–æ–ª–≥–æ ‚Äî —Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–Ω–∏–∂–∞–µ—Ç –ø—Ä–∏–±—ã–ª—å.",
        )
    if field == "returns_pct":
        return (
            "–í–≤–µ–¥–∏—Ç–µ % –∑–∞–∫–∞–∑–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç. –ù–∞–ø—Ä–∏–º–µ—Ä: 5",
            "–ù—É–∂–µ–Ω, —á—Ç–æ–±—ã –ø–æ—Å—á–∏—Ç–∞—Ç—å –æ–∂–∏–¥–∞–µ–º—ã–µ —Ä–∞—Å—Ö–æ–¥—ã –Ω–∞ –≤–æ–∑–≤—Ä–∞—Ç—ã –Ω–∞ –∫–∞–∂–¥—É—é –ø—Ä–æ–¥–∞–∂—É.",
        )
    if field == "return_cost":
        return (
            "–í–≤–µ–¥–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫–∏ –û–î–ù–û–ì–û –≤–æ–∑–≤—Ä–∞—Ç–∞ (‚ÇΩ).",
            "–ú—ã —É–º–Ω–æ–∂–∏–º –µ—ë –Ω–∞ –¥–æ–ª—é –≤–æ–∑–≤—Ä–∞—Ç–æ–≤ –∏ –ø–æ–ª—É—á–∏–º —Å—Ä–µ–¥–Ω–∏–π —Ä–∞—Å—Ö–æ–¥ –Ω–∞ –≤–æ–∑–≤—Ä–∞—Ç—ã –Ω–∞ –æ–¥–Ω—É –ø—Ä–æ–¥–∞–∂—É.",
        )
    if field == "ads_mode":
        return (
            "–ö–∞–∫ —É—á–∏—Ç—ã–≤–∞—Ç—å —Ä–µ–∫–ª–∞–º—É?",
            "–í—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω—ã–π —Ä–µ–∂–∏–º: ‚ÇΩ/–ø—Ä–æ–¥–∞–∂–∞ –∏–ª–∏ –î–†–†%.",
        )
    if field == "ads_value":
        am = (state_data.get("inputs", {}).get("ads_mode", {}) or {}).get("value")
        if am == "DRR":
            return (
                "–í–≤–µ–¥–∏—Ç–µ –î–†–† (%). –ù–∞–ø—Ä–∏–º–µ—Ä: 12",
                "–†–µ–∫–ª–∞–º–∞ –±—É–¥–µ—Ç —Å—á–∏—Ç–∞—Ç—å—Å—è –∫–∞–∫ % –æ—Ç —Ü–µ–Ω—ã.",
            )
        return (
            "–í–≤–µ–¥–∏—Ç–µ —Ä–µ–∫–ª–∞–º—É –Ω–∞ 1 –ø—Ä–æ–¥–∞–∂—É (‚ÇΩ).",
            "–†–µ–∫–ª–∞–º–∞ –Ω–∞–ø—Ä—è–º—É—é —Å–Ω–∏–∂–∞–µ—Ç –ø—Ä–∏–±—ã–ª—å.",
        )
    if field == "other_fees":
        return (
            "–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ—á–∏–µ —Å–±–æ—Ä—ã (‚ÇΩ –Ω–∞ 1 –ø—Ä–æ–¥–∞–∂—É).",
            "–ü—Ä–∏—ë–º–∫–∞, –æ–±—Ä–∞–±–æ—Ç–∫–∞, —ç–∫–≤–∞–π—Ä–∏–Ω–≥ –∏ –¥—Ä. –ï—Å–ª–∏ –Ω–µ –∑–Ω–∞–µ—Ç–µ ‚Äî –º–æ–∂–Ω–æ 0, –Ω–æ —Ç–æ—á–Ω–æ—Å—Ç—å —Å–Ω–∏–∑–∏—Ç—Å—è.",
        )
    if field == "opex_var":
        return (
            "–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ—á–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã (‚ÇΩ –Ω–∞ 1 –ø—Ä–æ–¥–∞–∂—É).",
            "–õ—é–±—ã–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã (–±—Ä–∞–∫, –¥–æ–ø. —É–ø–∞–∫–æ–≤–∫–∞ –∏ —Ç.–ø.).",
        )
    if field == "tax_mode":
        return (
            "–ö–∞–∫ —Å—á–∏—Ç–∞–µ—Ç—Å—è –Ω–∞–ª–æ–≥?",
            "–í—ã–±–µ—Ä–∏—Ç–µ, —Å —á–µ–≥–æ —Å—á–∏—Ç–∞—Ç—å –Ω–∞–ª–æ–≥: —Å –≤—ã—Ä—É—á–∫–∏ –∏–ª–∏ —Å –ø—Ä–∏–±—ã–ª–∏ (–¥–æ—Ö–æ–¥—ã –º–∏–Ω—É—Å —Ä–∞—Å—Ö–æ–¥—ã).",
        )
    if field == "tax_rate":
        return (
            "–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞–≤–∫—É –Ω–∞–ª–æ–≥–∞ (%).",
            "–ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ —á–∏—Å—Ç–æ–π –ø—Ä–∏–±—ã–ª–∏ –ø–æ—Å–ª–µ –Ω–∞–ª–æ–≥–æ–≤.",
        )
    return ("–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ.", "–ù—É–∂–Ω–æ –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞.")


def _field_kb(field: str):
    from app.keyboards import input_help_kb  # –ª–æ–∫–∞–ª—å–Ω—ã–π –∏–º–ø–æ—Ä—Ç, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ü–∏–∫–ª–æ–≤

    if field == "commission_mode":
        return commission_mode_kb()
    if field == "ads_mode":
        return ads_mode_kb()
    if field == "tax_mode":
        return tax_mode_kb()
    allow_default = field in {"storage", "return_cost", "other_fees", "opex_var", "logistics"}
    allow_zero = field not in {"price"}
    return input_help_kb(field, allow_default=allow_default, allow_zero=allow_zero)


async def _ask_field(message: Message | CallbackQuery, state: FSMContext, field: str):
    await state.update_data(current_field=field)
    q, why = _field_prompt(field, state_data=await state.get_data())
    kb = _field_kb(field)
    text = f"{q}\n\n{why}"
    if isinstance(message, CallbackQuery):
        await message.message.edit_text(text, reply_markup=kb)
    else:
        await message.answer(text, reply_markup=kb)


async def _apply_default(repo: Repo, state: FSMContext, field: str) -> float:
    data = await state.get_data()
    mp = data.get("marketplace")
    scheme = data.get("scheme")
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø—Ä–∞–≤–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ reference_data.py
    from app.reference_data import get_reference_value
    
    key_map = {
        "logistics": "logistics_rub_per_sale",
        "storage": "storage_rub_per_sale",
        "return_cost": "return_cost_rub",
        "other_fees": "other_fees_rub_per_sale",
        "opex_var": "opex_var_rub_per_sale",
    }
    
    key = key_map.get(field)
    if not key or not mp or not scheme:
        return 0.0
    
    return get_reference_value(mp, scheme, key)


_FIELD_ORDER = [
    "price",
    "cogs",
    "commission_mode",
    "commission_value",
    "logistics",
    "storage",
    "returns_pct",
    "return_cost",
    "ads_mode",
    "ads_value",
    "other_fees",
    "opex_var",
    "tax_mode",
    "tax_rate",
]


def _next_field(data_inputs: dict) -> str | None:
    for f in _FIELD_ORDER:
        if f not in data_inputs:
            return f
    return None


def _prev_field(current: str) -> str | None:
    if current not in _FIELD_ORDER:
        return None
    idx = _FIELD_ORDER.index(current)
    if idx <= 0:
        return None
    return _FIELD_ORDER[idx - 1]


def _build_result_text(mp: str, scheme: str, inputs: dict, results: dict, accuracy: str, notes: list[str], options: list[str], sku_label: str | None = None) -> str:
    title_line = f"üì¶ {sku_label}" if sku_label else "üì¶ SKU"
    header = f"{title_line}\n{mp} / {scheme}"

    sign = "üî¥" if results["net_profit"] < 0 else "üü¢"

    getv = lambda k: inputs.get(k, {}).get("value")

    text_parts = [
        header,
        "",
        f"{sign} –ò—Ç–æ–≥ –ø–æ 1 –ø—Ä–æ–¥–∞–∂–µ",
        "",
        "üí∞ –§–∏–Ω–∞–Ω—Å—ã:",
        f"‚Ä¢ –í—ã—Ä—É—á–∫–∞: {fmt_money(float(getv('price') or 0))}",
        f"‚Ä¢ –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å: {fmt_money(results.get('net_profit'))}",
        f"‚Ä¢ –ú–∞—Ä–∂–∞: {fmt_pct(results.get('margin_pct'))}",
        f"‚Ä¢ –ü—Ä–∏–±—ã–ª—å –¥–æ –Ω–∞–ª–æ–≥–æ–≤: {fmt_money(results.get('profit_before_tax'))}",
        "",
        "üèó –†–∞—Å—Ö–æ–¥—ã –Ω–∞ 1 –ø—Ä–æ–¥–∞–∂—É:",
        f"‚Ä¢ –°–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å: {fmt_money(float(getv('cogs') or 0))}",
        f"‚Ä¢ –ö–æ–º–∏—Å—Å–∏—è –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–∞: {fmt_money(results.get('commission_rub'))}",
        f"‚Ä¢ –õ–æ–≥–∏—Å—Ç–∏–∫–∞: {fmt_money(float(getv('logistics') or 0))}",
        f"‚Ä¢ –•—Ä–∞–Ω–µ–Ω–∏–µ: {fmt_money(float(getv('storage') or 0))}",
        f"‚Ä¢ –†–µ–∫–ª–∞–º–∞: {fmt_money(results.get('ads_rub'))} (–î–†–† {fmt_pct(results.get('drr_pct'))})",
        f"‚Ä¢ –û–∂–∏–¥. –∑–∞—Ç—Ä–∞—Ç—ã –Ω–∞ –≤–æ–∑–≤—Ä–∞—Ç—ã: {fmt_money(results.get('returns_cost_expected'))}",
        f"‚Ä¢ –ü—Ä–æ—á–∏–µ —Å–±–æ—Ä—ã: {fmt_money(float(getv('other_fees') or 0))}",
        f"‚Ä¢ –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–ø–µ—Ä. —Ä–∞—Å—Ö–æ–¥—ã: {fmt_money(float(getv('opex_var') or 0))}",
        f"‚Ä¢ –ù–∞–ª–æ–≥: {fmt_money(results.get('tax'))}",
        "",
        "üìç –ö–ª—é—á–µ–≤—ã–µ —Ç–æ—á–∫–∏:",
        f"‚Ä¢ –¢–æ—á–∫–∞ –±–µ–∑—É–±—ã—Ç–æ—á–Ω–æ—Å—Ç–∏ (—Ü–µ–Ω–∞): {fmt_money(results.get('breakeven_price'))}",
        f"‚Ä¢ –ú–∞–∫—Å. —Ä–µ–∫–ª–∞–º–∞ –±–µ–∑ —É–±—ã—Ç–∫–∞: {fmt_money(results.get('max_ads_rub'))} (–¥–æ {fmt_pct(results.get('max_drr_pct'))} –î–†–†)",
        "",
        f"–¢–æ—á–Ω–æ—Å—Ç—å: {accuracy}",
    ]

    if notes:
        text_parts.append("")
        for n in notes[:6]:
            text_parts.append(f"- {n}")

    if options:
        text_parts.append("")
        text_parts.append("–í–∞—Ä–∏–∞–Ω—Ç—ã –¥–µ–π—Å—Ç–≤–∏–π (–ø–æ —Ü–∏—Ñ—Ä–∞–º):")
        for o in options[:4]:
            text_parts.append(f"‚Ä¢ {o}")

    return "\n".join(text_parts)


def _build_options(ci: CalcInputs, results: dict) -> list[str]:
    P = ci.price
    opts: list[str] = []

    # +5% –∏ +10% –∫ —Ü–µ–Ω–µ
    for pct in (0.05, 0.10):
        new_price = P * (1 + pct)
        ci2 = CalcInputs(**{**ci.__dict__, "price": new_price})
        r2 = compute(ci2)
        opts.append(
            f"–ï—Å–ª–∏ –ø–æ–¥–Ω—è—Ç—å —Ü–µ–Ω—É –Ω–∞ {int(pct * 100)}% –¥–æ {fmt_money(new_price)}, "
            f"—á–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å –±—É–¥–µ—Ç {fmt_money(r2['net_profit'])}, –º–∞—Ä–∂–∞ {fmt_pct(r2['margin_pct'])}."
        )

    # –±–µ–∑–æ–ø–∞—Å–Ω–∞—è —Ä–µ–∫–ª–∞–º–∞
    opts.append(
        "–ü—Ä–∏ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω–µ —Ä–µ–∫–ª–∞–º–∞ –Ω–∞ 1 –ø—Ä–æ–¥–∞–∂—É –Ω–µ –¥–æ–ª–∂–Ω–∞ –ø—Ä–µ–≤—ã—à–∞—Ç—å "
        f"{fmt_money(results['max_ads_rub'])} (‚âà {fmt_pct(results['max_drr_pct'])} –î–†–†), "
        "—á—Ç–æ–±—ã SKU –Ω–µ —É—Ö–æ–¥–∏–ª –≤ –º–∏–Ω—É—Å."
    )

    # –µ—Å–ª–∏ SKU —É–±—ã—Ç–æ—á–µ–Ω –¥–∞–∂–µ –±–µ–∑ —Ä–µ–∫–ª–∞–º—ã
    if results["net_profit"] < 0:
        ci3 = CalcInputs(**{**ci.__dict__, "ads_mode": "PER_SALE", "ads_value": 0.0})
        r3 = compute(ci3)
        if r3["net_profit"] <= 0:
            opts.append(
                "–î–∞–∂–µ –µ—Å–ª–∏ —Å–æ–≤—Å–µ–º –æ—Ç–∫–ª—é—á–∏—Ç—å —Ä–µ–∫–ª–∞–º—É, SKU –æ—Å—Ç–∞—ë—Ç—Å—è —É–±—ã—Ç–æ—á–Ω—ã–º ‚Äî "
                "–Ω–∞–¥–æ –ø–µ—Ä–µ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å, –ª–æ–≥–∏—Å—Ç–∏–∫—É, –∫–æ–º–∏—Å—Å–∏—é –∏–ª–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—é (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ä–∞—Å–ø—Ä–æ–¥–∞–∂–∞)."
            )

    return opts


async def _finish_and_show_result(message_or_cb, repo: Repo, state: FSMContext, from_history: bool = False):
    data = await state.get_data()
        # –û—Ç–ª–∞–¥–∫–∞: —á—Ç–æ –µ—Å—Ç—å –≤ state
    print(f"DEBUG finish: data keys = {list(data.keys())}")
    print(f"DEBUG finish: marketplace = {data.get('marketplace')}")
    print(f"DEBUG finish: scheme = {data.get('scheme')}")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
    if not data.get("marketplace") or not data.get("scheme"):
        error_msg = f"–û—à–∏–±–∫–∞: marketplace={data.get('marketplace')}, scheme={data.get('scheme')}"
        print(f"ERROR: {error_msg}")
        if isinstance(message_or_cb, Message):
            await message_or_cb.answer("–û—à–∏–±–∫–∞: –Ω–µ –≤—ã–±—Ä–∞–Ω –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å –∏–ª–∏ —Å—Ö–µ–º–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
        else:
            await message_or_cb.message.answer("–û—à–∏–±–∫–∞: –Ω–µ –≤—ã–±—Ä–∞–Ω –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å –∏–ª–∏ —Å—Ö–µ–º–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
        return
    
    inputs = data.get("inputs", {})
    mp = data["marketplace"]
    scheme = data["scheme"]
    sku_label = data.get("sku_label")

    inputs = data.get("inputs", {})
    mp = data.get("marketplace")
    scheme = data.get("scheme")
    sku_label = data.get("sku_label")

    ci = _build_calcinputs(inputs)
    results = compute(ci)
    acc, notes = _notes(inputs)
    options = _build_options(ci, results)

    # —Å–ø–∏—Å—ã–≤–∞–µ–º –∫—Ä–µ–¥–∏—Ç —Ç–æ–ª—å–∫–æ –¥–ª—è "–∂–∏–≤–æ–≥–æ" —Ä–∞—Å—á—ë—Ç–∞
    if not from_history:
        try:
            used = await repo.consume_credit(
                (message_or_cb.from_user.id if isinstance(message_or_cb, Message) else message_or_cb.from_user.id)
            )
        except RuntimeError as e:
            if str(e) == "NO_CREDITS":
                if isinstance(message_or_cb, Message):
                    await message_or_cb.answer(
                        "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Ä–∞—Å—á—ë—Ç—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å. –ù—É–∂–Ω–æ –∫—É–ø–∏—Ç—å –ø–∞–∫–µ—Ç SKU.",
                        reply_markup=packs_kb(),
                    )
                else:
                    await message_or_cb.message.answer(
                        "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Ä–∞—Å—á—ë—Ç—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å. –ù—É–∂–Ω–æ –∫—É–ø–∏—Ç—å –ø–∞–∫–µ—Ç SKU.",
                        reply_markup=packs_kb(),
                    )
                return
            raise
        await state.update_data(used_credit_type=used)

    text = _build_result_text(mp, scheme, inputs, results, acc, notes, options, sku_label=sku_label)

    await state.update_data(
        results=results,
        accuracy=acc,
        accuracy_notes=notes,
        options=options,
    )

    if isinstance(message_or_cb, Message):
        await message_or_cb.answer(text, reply_markup=result_kb())
    else:
        await message_or_cb.message.edit_text(text, reply_markup=result_kb())

    await state.set_state(CalcFlow.confirm)


@router.message(CommandStart())
async def cmd_start(message: Message, repo: Repo):
    await repo.upsert_user_on_start(message.from_user.id)
    u = await repo.get_user(message.from_user.id)
    left = u["free_credits"] if u else 0
    await message.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–º–æ–≥—É —Ç–æ—á–Ω–æ –ø–æ—Å—á–∏—Ç–∞—Ç—å –ø—Ä–∏–±—ã–ª—å/—É–±—ã—Ç–æ–∫ –ø–æ SKU —Å —É—á—ë—Ç–æ–º –∫–æ–º–∏—Å—Å–∏–π, –ª–æ–≥–∏—Å—Ç–∏–∫–∏, —Ä–µ–∫–ª–∞–º—ã –∏ –Ω–∞–ª–æ–≥–æ–≤.\n\n"
        f"–û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö —Ä–∞—Å—á—ë—Ç–æ–≤: {left}",
        reply_markup=main_menu_kb(),
    )


@router.callback_query(F.data == "menu")
async def menu(cb: CallbackQuery, repo: Repo, state: FSMContext):
    await state.clear()
    u = await repo.get_user(cb.from_user.id)
    left = u["free_credits"] if u else 0
    await cb.message.edit_text(
        f"–ú–µ–Ω—é. –û—Å—Ç–∞–ª–æ—Å—å –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö —Ä–∞—Å—á—ë—Ç–æ–≤: {left}", reply_markup=main_menu_kb()
    )


@router.callback_query(F.data == "help:how")
async def how(cb: CallbackQuery):
    await cb.message.edit_text(
        "–ö–∞–∫ —Å—á–∏—Ç–∞–µ—Ç—Å—è:\n"
        "‚Ä¢ –ú—ã —Å—á–∏—Ç–∞–µ–º –ø—Ä–∏–±—ã–ª—å –Ω–∞ 1 –ø—Ä–æ–¥–∞–∂—É –ø–æ –≤–≤–µ–¥—ë–Ω–Ω—ã–º —Ü–∏—Ñ—Ä–∞–º.\n"
        "‚Ä¢ –í–æ–∑–≤—Ä–∞—Ç—ã —É—á–∏—Ç—ã–≤–∞—é—Ç—Å—è –∫–∞–∫ –æ–∂–∏–¥–∞–µ–º—ã–µ —Ä–∞—Å—Ö–æ–¥—ã –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É/–ª–æ–≥–∏—Å—Ç–∏–∫—É –Ω–∞ –∫–∞–∂–¥—É—é –ø—Ä–æ–¥–∞–∂—É.\n"
        "‚Ä¢ –ù–∞–ª–æ–≥–∏ —Å—á–∏—Ç–∞—é—Ç—Å—è —É–ø—Ä–∞–≤–ª–µ–Ω—á–µ—Å–∫–∏ ‚Äî —á—Ç–æ–±—ã –≤—ã –º–æ–≥–ª–∏ –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ä–µ—à–µ–Ω–∏—è –ø–æ —Ü–µ–Ω–µ –∏ —Ä–µ–∫–ª–∞–º–µ.\n"
        "‚Ä¢ –ß–µ–º –º–µ–Ω—å—à–µ —Å–ø—Ä–∞–≤–æ—á–Ω—ã—Ö/–Ω—É–ª–µ–≤—ã—Ö –ø–æ–ª–µ–π, —Ç–µ–º –≤—ã—à–µ —Ç–æ—á–Ω–æ—Å—Ç—å.",
        reply_markup=main_menu_kb(),
    )


@router.callback_query(F.data == "calc:start")
async def calc_start(cb: CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(CalcFlow.entering_label)
    await cb.message.edit_text(
        "–ö–∞–∫ –Ω–∞–∑–æ–≤—ë–º —ç—Ç–æ—Ç —Ä–∞—Å—á—ë—Ç?\n\n"
        "–ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –∏–ª–∏ –∞—Ä—Ç–∏–∫—É–ª SKU –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
        reply_markup=None,
    )

@router.message(CalcFlow.entering_label)
async def enter_label(message: Message, state: FSMContext):
    label = (message.text or "").strip()
    if not label:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –ø—É—Å—Ç–æ–µ. –ù–∞–ø–∏—à–∏—Ç–µ —Ö–æ—Ç—è –±—ã —á—Ç–æ-—Ç–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –±—Ä–µ–Ω–¥ + –º–æ–¥–µ–ª—å).")
        return

    await state.update_data(sku_label=label)
    await state.set_state(CalcFlow.entering_value)
    await _ask_field(message, state, "price")

@router.callback_query(F.data.startswith("calc:mp:"))
async def choose_mp(cb: CallbackQuery, state: FSMContext):
    mp = cb.data.split(":")[-1]
    # –í–∞–∂–Ω–æ: —Å–æ—Ö—Ä–∞–Ω—è–µ–º marketplace –≤ state
    await state.update_data(marketplace=mp, inputs={})
    await state.set_state(CalcFlow.choosing_scheme)
    from app.constants import SCHEMES_BY_MP

    if mp not in SCHEMES_BY_MP:
        await cb.message.edit_text(
            "–î–ª—è —ç—Ç–æ–≥–æ –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–∞ —Å—Ö–µ–º—ã –ø–æ–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã.", reply_markup=main_menu_kb()
        )
        return
    await cb.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ö–µ–º—É —Ä–∞–±–æ—Ç—ã:", reply_markup=schemes_kb(mp))

@router.callback_query(F.data.startswith("calc:scheme:"))
async def choose_scheme(cb: CallbackQuery, state: FSMContext):
    scheme = cb.data.split(":")[-1]
    # –í–∞–∂–Ω–æ: —Å–æ—Ö—Ä–∞–Ω—è–µ–º scheme –≤ state
    await state.update_data(scheme=scheme)
    await state.set_state(CalcFlow.entering_label)
    await cb.message.edit_text(
        "–ö–∞–∫ –Ω–∞–∑–æ–≤—ë–º —ç—Ç–æ—Ç —Ä–∞—Å—á—ë—Ç?\n\n"
        "–ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –∏–ª–∏ –∞—Ä—Ç–∏–∫—É–ª (–º–æ–∂–Ω–æ –∫–æ—Ä–æ—Ç–∫–æ).",
        reply_markup=None
    )

@router.message(CalcFlow.entering_label)
async def enter_label(message: Message, state: FSMContext):
    label = (message.text or "").strip()
    if not label:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –ø—É—Å—Ç–æ–µ. –ù–∞–ø–∏—à–∏—Ç–µ, –∫–∞–∫ –±—É–¥–µ–º –æ–±–æ–∑–Ω–∞—á–∞—Ç—å —ç—Ç–æ—Ç SKU.")
        return

    await state.update_data(sku_label=label, inputs={})
    await state.set_state(CalcFlow.entering_value)
    await _ask_field(message, state, "price")


@router.callback_query(F.data == "calc:back:mp")
async def back_to_mp(cb: CallbackQuery, state: FSMContext):
    await state.set_state(CalcFlow.choosing_mp)
    await cb.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å:", reply_markup=marketplaces_kb())


@router.callback_query(F.data == "calc:back:field")
async def back_field(cb: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    current = data.get("current_field")
    if not current:
        await cb.answer("–ù–∞–∑–∞–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ", show_alert=True)
        return

    if current == "price":
        await state.set_state(CalcFlow.entering_label)
        await cb.message.edit_text(
            "–ò–∑–º–µ–Ω–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–∞—Å—á—ë—Ç–∞.\n\n"
            "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –∏–ª–∏ –∞—Ä—Ç–∏–∫—É–ª.\n\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ–º."
        )
        return

    prev_field = _prev_field(current)
    if not prev_field:
        await cb.answer("–ù–∞–∑–∞–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ", show_alert=True)
        return

    await _ask_field(cb, state, prev_field)


@router.callback_query(F.data.startswith("calc:enter:"))
async def enter_value_prompt(cb: CallbackQuery, state: FSMContext):
    field = cb.data.split(":")[-1]
    await state.update_data(current_field=field, awaiting_text=True)
    q, why = _field_prompt(field, await state.get_data())
    await state.set_state(CalcFlow.entering_value)
    await cb.message.edit_text(
        f"{q}\n\n{why}\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ —á–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–µ–º.", reply_markup=None
    )


@router.message(CalcFlow.entering_value)
async def enter_value_message(message: Message, state: FSMContext, repo: Repo):
    data = await state.get_data()
    field = data.get("current_field")
    if not field:
        return

    inputs = data.get("inputs", {})

    try:
        if field in {"returns_pct", "commission_value", "ads_value", "tax_rate"}:
            if field == "returns_pct":
                v = _pct_to_frac(message.text)
            elif field == "tax_rate":
                v = _pct_to_frac(message.text)
            elif field == "commission_value":
                cm = inputs.get("commission_mode", {}).get("value")
                v = _pct_to_frac(message.text) if cm == "PCT" else _safe_float(message.text)
            elif field == "ads_value":
                am = inputs.get("ads_mode", {}).get("value")
                v = _pct_to_frac(message.text) if am == "DRR" else _safe_float(message.text)
            else:
                v = _safe_float(message.text)
        else:
            v = _safe_float(message.text)

        _set_input(inputs, field, v, "USER")
        await state.update_data(inputs=inputs)
    except Exception:
        await message.answer("–ù–µ —Å–º–æ–≥ —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —á–∏—Å–ª–æ. –ü—Ä–∏–º–µ—Ä: 1234 –∏–ª–∏ 12,5")
        return

    nextf = _next_field(inputs)
    if nextf is None:
        await _finish_and_show_result(message, repo, state, from_history=False)
        return

    if nextf in {"commission_mode", "ads_mode", "tax_mode"}:
        await _ask_field(message, state, nextf)
        return

    await _ask_field(message, state, nextf)


@router.callback_query(F.data.startswith("calc:commode:"))
async def commode(cb: CallbackQuery, state: FSMContext):
    mode = cb.data.split(":")[-1]
    data = await state.get_data()
    inputs = data.get("inputs", {})
    _set_input(inputs, "commission_mode", mode, "USER")
    await state.update_data(inputs=inputs)
    await _ask_field(cb, state, "commission_value")


@router.callback_query(F.data.startswith("calc:adsmode:"))
async def adsmode(cb: CallbackQuery, state: FSMContext):
    mode = cb.data.split(":")[-1]
    data = await state.get_data()
    inputs = data.get("inputs", {})
    _set_input(inputs, "ads_mode", mode, "USER")
    await state.update_data(inputs=inputs)
    await _ask_field(cb, state, "ads_value")


@router.callback_query(F.data.startswith("calc:tax:"))
async def taxmode(cb: CallbackQuery, state: FSMContext):
    mode = cb.data.split(":")[-1]
    data = await state.get_data()
    inputs = data.get("inputs", {})
    _set_input(inputs, "tax_mode", mode, "USER")
    await state.update_data(inputs=inputs)
    await _ask_field(cb, state, "tax_rate")


@router.callback_query(F.data.startswith("calc:default:"))
async def field_default(cb: CallbackQuery, state: FSMContext, repo: Repo):
    field = cb.data.split(":")[-1]
    data = await state.get_data()
    inputs = data.get("inputs", {})
    v = await _apply_default(repo, state, field)
    source = "DEFAULT" if v != 0 else "ZERO"
    _set_input(inputs, field, v, source)
    await state.update_data(inputs=inputs)
    nextf = _next_field(inputs)
    if nextf:
        await _ask_field(cb, state, nextf)
    else:
        await cb.message.answer("–ì–æ—Ç–æ–≤–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –ª—é–±–æ–µ —á–∏—Å–ª–æ, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.")


@router.callback_query(F.data.startswith("calc:zero:"))
async def field_zero(cb: CallbackQuery, state: FSMContext):
    field = cb.data.split(":")[-1]
    data = await state.get_data()
    inputs = data.get("inputs", {})
    _set_input(inputs, field, 0.0, "ZERO")
    await state.update_data(inputs=inputs)
    nextf = _next_field(inputs)
    if nextf:
        await _ask_field(cb, state, nextf)


@router.callback_query(F.data == "calc:save")
async def save_calc(cb: CallbackQuery, state: FSMContext, repo: Repo):
    data = await state.get_data()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –í–°–ï –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–æ–ª—è
    required_fields = ["results", "marketplace", "scheme"]
    missing_fields = [field for field in required_fields if field not in data or not data[field]]
    
    if missing_fields:
        await cb.answer(f"–ù–µ–ª—å–∑—è —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å: –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç {', '.join(missing_fields)}", show_alert=True)
        return
    
    try:
        inputs = data.get("inputs", {})
        results = data["results"]
        mp = data["marketplace"]  # –¢–µ–ø–µ—Ä—å —Ç–æ—á–Ω–æ –µ—Å—Ç—å
        scheme = data["scheme"]   # –¢–µ–ø–µ—Ä—å —Ç–æ—á–Ω–æ –µ—Å—Ç—å
        used = data.get("used_credit_type", "FREE")
        acc = data.get("accuracy", "")
        sku_label = data.get("sku_label", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
        
        # –û—Ç–ª–∞–¥–∫–∞
        print(f"DEBUG save_calc: user={cb.from_user.id}, mp={mp}, scheme={scheme}, label={sku_label}")
        
        calc_id = await repo.save_calculation(
            tg_user_id=cb.from_user.id,
            marketplace=mp,
            scheme=scheme,
            sku_label=sku_label,
            inputs=inputs,
            results=results,
            accuracy_level=acc,
            used_credit_type=used,
        )
        
        await state.update_data(current_calc_id=calc_id)
        await cb.answer("‚úÖ –†–∞—Å—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ '–ú–æ–∏ —Ä–∞—Å—á—ë—Ç—ã'", show_alert=False)
        
    except Exception as e:
        print(f"ERROR save_calc: {e}")
        await cb.answer(f"–û—à–∏–±–∫–∞: {str(e)[:100]}", show_alert=True)

@router.callback_query(F.data == "calc:pdf")
async def pdf_calc(cb: CallbackQuery, state: FSMContext, repo: Repo, bot: Bot):
    data = await state.get_data()
    if "results" not in data:
        await cb.answer("–°–Ω–∞—á–∞–ª–∞ —Å–¥–µ–ª–∞–π—Ç–µ —Ä–∞—Å—á—ë—Ç", show_alert=True)
        return

    mp = data.get("marketplace")
    scheme = data.get("scheme")
    inputs = data.get("inputs", {})
    results = data.get("results", {})
    acc = data.get("accuracy", "")
    notes = data.get("accuracy_notes", [])
    options = data.get("options", [])
    sku_label = data.get("sku_label")

    def getv(k):
        return inputs.get(k, {}).get("value")

    in_sum = [
        ("–ú–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å", mp),
        ("–°—Ö–µ–º–∞", scheme),
        ("–ù–∞–∑–≤–∞–Ω–∏–µ / SKU", sku_label or "-"),
        ("–¶–µ–Ω–∞", fmt_money(float(getv("price") or 0))),
        ("–°–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å", fmt_money(float(getv("cogs") or 0))),
        ("–õ–æ–≥–∏—Å—Ç–∏–∫–∞", fmt_money(float(getv("logistics") or 0))),
        ("–•—Ä–∞–Ω–µ–Ω–∏–µ", fmt_money(float(getv("storage") or 0))),
        ("–í–æ–∑–≤—Ä–∞—Ç—ã, % –∑–∞–∫–∞–∑–æ–≤", fmt_pct(float(getv("returns_pct") or 0) * 100)),
        ("–°—Ç–æ–∏–º–æ—Å—Ç—å –æ–¥–Ω–æ–≥–æ –≤–æ–∑–≤—Ä–∞—Ç–∞", fmt_money(float(getv("return_cost") or 0))),
        ("–†–µ–∫–ª–∞–º–∞", f"{fmt_money(results.get('ads_rub'))} (–î–†–† {fmt_pct(results.get('drr_pct'))})"),
        ("–ü—Ä–æ—á–∏–µ —Å–±–æ—Ä—ã", fmt_money(float(getv("other_fees") or 0))),
        ("–ü—Ä–æ—á–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã", fmt_money(float(getv("opex_var") or 0))),
        ("–ù–∞–ª–æ–≥", fmt_money(results.get("tax"))),
    ]

    res_sum = [
        ("–ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å", fmt_money(results.get("net_profit"))),
        ("–ú–∞—Ä–∂–∞", fmt_pct(results.get("margin_pct"))),
        ("–ü—Ä–∏–±—ã–ª—å –¥–æ –Ω–∞–ª–æ–≥–æ–≤", fmt_money(results.get("profit_before_tax"))),
        ("–ë–µ–∑—É–±—ã—Ç–æ–∫ (—Ü–µ–Ω–∞)", fmt_money(results.get("breakeven_price"))),
        ("–ú–∞–∫—Å. —Ä–µ–∫–ª–∞–º–∞", f"{fmt_money(results.get('max_ads_rub'))} (–¥–æ {fmt_pct(results.get('max_drr_pct'))} –î–†–†)"),
        ("–ö–æ–º–∏—Å—Å–∏—è", fmt_money(results.get("commission_rub"))),
        ("–û–∂–∏–¥. –∑–∞—Ç—Ä–∞—Ç—ã –Ω–∞ –≤–æ–∑–≤—Ä–∞—Ç—ã", fmt_money(results.get("returns_cost_expected"))),
    ]

    pdf_bytes = build_pdf(
        title="–û—Ç—á—ë—Ç –ø–æ SKU (1 –ø—Ä–æ–¥–∞–∂–∞)",
        subtitle=f"{mp} / {scheme}",
        inputs_summary=in_sum,
        results_summary=res_sum,
        accuracy=acc,
        accuracy_notes=notes,
        options=options,
    )

    doc = BufferedInputFile(pdf_bytes, filename="sku_report.pdf")
    await bot.send_document(cb.from_user.id, doc)
    await cb.answer()


@router.callback_query(F.data.startswith("calc:history:"))
async def history(cb: CallbackQuery, repo: Repo):
    offset = int(cb.data.split(":")[-1])
    rows = await repo.list_calculations(cb.from_user.id, limit=10, offset=offset)

    if not rows and offset != 0:
        await cb.answer("–ë–æ–ª—å—à–µ –Ω–µ—Ç", show_alert=False)
        return
    if not rows:
        await cb.message.edit_text("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.", reply_markup=main_menu_kb())
        return

    lines = ["–í–∞—à–∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ —Ä–∞—Å—á—ë—Ç—ã:"]
    for r in rows:
        res = r.get("results") if isinstance(r.get("results"), dict) else {}
        np = res.get("net_profit")
        lines.append(
            f"‚Ä¢ #{r['id']} {r['marketplace']}/{r['scheme']} ‚Äî –ø—Ä–∏–±—ã–ª—å {fmt_money(np)} ‚Äî {r['accuracy_level']}"
        )

    kb = InlineKeyboardBuilder()
    for r in rows:
        kb.button(
            text=f"–û—Ç–∫—Ä—ã—Ç—å #{r['id']} ({r['marketplace']}/{r['scheme']})",
            callback_data=f"calc:open:{r['id']}",
        )
    kb.adjust(1)

    prev_off = max(0, offset - 10)
    next_off = offset + 10
    kb.row(
        InlineKeyboardButton(text="‚óÄÔ∏è", callback_data=f"calc:history:{prev_off}"),
        InlineKeyboardButton(text="‚ñ∂Ô∏è", callback_data=f"calc:history:{next_off}"),
    )
    kb.row(InlineKeyboardButton(text="üè† –ú–µ–Ω—é", callback_data="menu"))

    await cb.message.edit_text("\n".join(lines), reply_markup=kb.as_markup())


@router.callback_query(F.data.startswith("calc:open:"))
async def open_saved(cb: CallbackQuery, repo: Repo, state: FSMContext):
    calc_id = int(cb.data.split(":")[-1])
    row = await repo.get_calculation(cb.from_user.id, calc_id)
    if not row:
        await cb.answer("–†–∞—Å—á—ë—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    # --- –∞–∫–∫—É—Ä–∞—Ç–Ω–æ –¥–æ—Å—Ç–∞—ë–º inputs / results –∏–∑ JSON –∏–ª–∏ dict ---
    raw_inputs = row.get("inputs") or {}
    if isinstance(raw_inputs, str):
        try:
            inputs = json.loads(raw_inputs)
        except Exception:
            inputs = {}
    else:
        inputs = raw_inputs or {}

    raw_results = row.get("results") or {}
    if isinstance(raw_results, str):
        try:
            results = json.loads(raw_results)
        except Exception:
            results = {}
    else:
        results = raw_results or {}

    mp = row.get("marketplace")
    scheme = row.get("scheme")
    sku_label = row.get("sku_label")

    # –ü—ã—Ç–∞–µ–º—Å—è –ø–µ—Ä–µ—Å—á–∏—Ç–∞—Ç—å –ø–æ —Ç–µ–∫—É—â–µ–π —Ñ–æ—Ä–º—É–ª–µ,
    # –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏—Ç—Å—è ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ results –∫–∞–∫ –µ—Å—Ç—å
    ci = None
    try:
        ci = _build_calcinputs(inputs)
        results = compute(ci)
    except Exception:
        pass

    acc, notes = _notes(inputs)
    options = _build_options(ci, results) if ci is not None else []

    await state.update_data(
        inputs=inputs,
        results=results,
        marketplace=mp,
        scheme=scheme,
        sku_label=sku_label,
        accuracy=acc,
        accuracy_notes=notes,
        options=options,
        used_credit_type=row.get("used_credit_type", "HISTORY"),
        current_calc_id=calc_id,
    )

    text = _build_result_text(mp, scheme, inputs, results, acc, notes, options, sku_label=sku_label)
    await cb.message.edit_text(text, reply_markup=result_saved_kb(calc_id))


@router.callback_query(F.data.startswith("calc:delete:"))
async def delete_saved(cb: CallbackQuery, repo: Repo, state: FSMContext):
    calc_id = int(cb.data.split(":")[-1])
    ok = await repo.delete_calculation(cb.from_user.id, calc_id)
    if not ok:
        await cb.answer("–ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Ä–∞—Å—á—ë—Ç", show_alert=True)
        return
    await cb.answer("–£–¥–∞–ª–µ–Ω–æ", show_alert=False)

    rows = await repo.list_calculations(cb.from_user.id, limit=10, offset=0)
    if not rows:
        await cb.message.edit_text("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.", reply_markup=main_menu_kb())
        return
    lines = ["–í–∞—à–∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ —Ä–∞—Å—á—ë—Ç—ã:"]
    for r in rows:
        res = r.get("results") if isinstance(r.get("results"), dict) else {}
        np = res.get("net_profit")
        lines.append(
            f"‚Ä¢ #{r['id']} {r['marketplace']}/{r['scheme']} ‚Äî –ø—Ä–∏–±—ã–ª—å {fmt_money(np)} ‚Äî {r['accuracy_level']}"
        )

    kb = InlineKeyboardBuilder()
    for r in rows:
        kb.button(
            text=f"–û—Ç–∫—Ä—ã—Ç—å #{r['id']} ({r['marketplace']}/{r['scheme']})",
            callback_data=f"calc:open:{r['id']}",
        )
    kb.adjust(1)
    kb.row(
        InlineKeyboardButton(text="‚óÄÔ∏è", callback_data="calc:history:0"),
        InlineKeyboardButton(text="‚ñ∂Ô∏è", callback_data="calc:history:10"),
    )
    kb.row(InlineKeyboardButton(text="üè† –ú–µ–Ω—é", callback_data="menu"))

    await cb.message.edit_text("\n".join(lines), reply_markup=kb.as_markup())
